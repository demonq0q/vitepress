::: code-group

```c
// åŸºäºŽé“¾è¡¨å®žçŽ°çš„æ ˆ
typedef struct{
    ListNode *top; // å°†å¤´ç»“ç‚¹ä½œä¸ºæ ˆé¡¶
    int size; // æ ˆçš„é•¿åº¦
} LinkedListStack;

// æž„é€ å‡½æ•°
LinkedListStack *newLinkedListStack(){
    LinkedListStack *s = malloc(sizeof(LinkedListStack));
    s -> top = NULL;
    s -> size = 0;
    return s;
}

// æžæž„å‡½æ•°
void delLinkedListStack(LinkedListStack *s){
    while(s->top){
        ListNode *n = s->top->next;
        free(s->top);
        s->top = n;
    }
    free(s);
}

// èŽ·å–æ ˆçš„é•¿åº¦
int size(LinkedListStack *s){
    return s->size;
}

// åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
bool isEmpty(LinkedListStack){
    return size(s) == 0;
}

// å…¥æ ˆ
void push(LinkedListStack *s, int num){
    ListNode *node = (ListNode *)malloc(sizeof(ListNode));
    node->next = s->top; // æ›´æ–°æ–°åŠ èŠ‚ç‚¹æŒ‡é’ˆåŸŸ
    node->val = num; // æ›´æ–°æ–°åŠ èŠ‚ç‚¹æ•°æ®åŸŸ
    s->top = num; // æ›´æ–°æ ˆé¡¶
    s->size++; // æ›´æ–°æ ˆå¤§å°
}

// è®¿é—®æ ˆé¡¶å…ƒç´ 
int peek(LinkedListStack *s){
    if(s->size == 0){
        printf("æ ˆä¸ºç©º\n");
        return INT_MAX;
    }
    return s->top->val;
}

// å‡ºæ ˆ
int pop(LinkedListStack *s){
    int val = peek(s);
    ListNode *tmp = s->top;
    s->top = s->top->next;
    // é‡Šæ”¾å†…å­˜
    free(tmp);
    s->size--;
    return val;
}
```

```c++
// åŸºäºŽé“¾è¡¨å®žçŽ°çš„æ ˆ
class LinkedListStack{
    private:
        ListNode *stackTop; // å°†å¤´èŠ‚ç‚¹ä½œä¸ºæ ˆé¡¶
        int stkSize; // æ ˆçš„é•¿åº¦

    public:
        LinkedListStack(){
            stackTop = nullptr;
            stkSize = 0;
    }

        ~LinkedListStack(){
            // éåŽ†é“¾è¡¨åˆ é™¤èŠ‚ç‚¹ï¼Œé‡Šæ”¾å†…å­˜
            freeMemoryLinkedList(stackTop);
    }

        // èŽ·å–æ ˆçš„é•¿åº¦
        int size(){
            return stkSize;
    }

        // åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
        bool isEmpty(){
            return size() == 0;
    }

        // å…¥æ ˆ
        void push(int num){
            ListNode *node = new ListNode(num);
            node->next = stackTop;
            stackTop = node;
            stkSize++;
    }

        // å‡ºæ ˆ
        int pop(){
            int num = top();
            ListNode *tmp = stackTop;
            stackTop = stackTop->next;
            // é‡Šæ”¾å†…å­˜
            delete tmp;
            stkSize--;
        return num;
    }

        /* è®¿é—®æ ˆé¡¶å…ƒç´  */
        int top() {
            if (isEmpty())
                throw out_of_range("æ ˆä¸ºç©º");
            return stackTop->val;
    }

        /* å°† List è½¬åŒ–ä¸º Array å¹¶è¿”å›ž */
        vector<int> toVector() {
            ListNode *node = stackTop;
            vector<int> res(size());
            for (int i = res.size() - 1; i >= 0; i--) {
                res[i] = node->val;
                node = node->next;
        }
        return res;
    }
};
```

:::


# Markdown Extension Examples

This page demonstrates some of the built-in markdown extensions provided by VitePress.

## Syntax Highlighting

VitePress provides Syntax Highlighting powered by [Shikiji](https://github.com/antfu/shikiji), with additional features like line-highlighting:

**Input**

````md
```js{4}
export default {
  data () {
    return {
      msg: 'Highlighted!'
    }
  }
}
```
````

**Output**

```js{4}
export default {
  data () {
    return {
      msg: 'Highlighted!'
    }
  }
}
```

## Custom Containers

**Input**

```md
::: info
This is an info box.
:::

::: tip
This is a tip.
:::

::: warning
This is a warning.
:::

::: danger
This is a dangerous warning.
:::

::: details
This is a details block.
:::
```

**Output**

::: info
This is an info box.
:::

::: tip ðŸ’¡ Tip
This is a tip.
:::

::: warning
This is a warning.
:::

::: danger
This is a dangerous warning.
:::

::: details
This is a details block.
:::

## More

Check out the documentation for the [full list of markdown extensions](https://vitepress.dev/guide/markdown).
