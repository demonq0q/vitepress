::: code-group

```c
// 基于链表实现的栈
typedef struct{
    ListNode *top; // 将头结点作为栈顶
    int size; // 栈的长度
} LinkedListStack;

// 构造函数
LinkedListStack *newLinkedListStack(){
    LinkedListStack *s = malloc(sizeof(LinkedListStack));
    s -> top = NULL;
    s -> size = 0;
    return s;
}

// 析构函数
void delLinkedListStack(LinkedListStack *s){
    while(s->top){
        ListNode *n = s->top->next;
        free(s->top);
        s->top = n;
    }
    free(s);
}

// 获取栈的长度
int size(LinkedListStack *s){
    return s->size;
}

// 判断栈是否为空
bool isEmpty(LinkedListStack){
    return size(s) == 0;
}

// 入栈
void push(LinkedListStack *s, int num){
    ListNode *node = (ListNode *)malloc(sizeof(ListNode));
    node->next = s->top; // 更新新加节点指针域
    node->val = num; // 更新新加节点数据域
    s->top = num; // 更新栈顶
    s->size++; // 更新栈大小
}

// 访问栈顶元素
int peek(LinkedListStack *s){
    if(s->size == 0){
        printf("栈为空\n");
        return INT_MAX;
    }
    return s->top->val;
}

// 出栈
int pop(LinkedListStack *s){
    int val = peek(s);
    ListNode *tmp = s->top;
    s->top = s->top->next;
    // 释放内存
    free(tmp);
    s->size--;
    return val;
}
```

```c++
// 基于链表实现的栈
class LinkedListStack{
    private:
        ListNode *stackTop; // 将头节点作为栈顶
        int stkSize; // 栈的长度

    public:
        LinkedListStack(){
            stackTop = nullptr;
            stkSize = 0;
    }

        ~LinkedListStack(){
            // 遍历链表删除节点，释放内存
            freeMemoryLinkedList(stackTop);
    }

        // 获取栈的长度
        int size(){
            return stkSize;
    }

        // 判断栈是否为空
        bool isEmpty(){
            return size() == 0;
    }

        // 入栈
        void push(int num){
            ListNode *node = new ListNode(num);
            node->next = stackTop;
            stackTop = node;
            stkSize++;
    }

        // 出栈
        int pop(){
            int num = top();
            ListNode *tmp = stackTop;
            stackTop = stackTop->next;
            // 释放内存
            delete tmp;
            stkSize--;
        return num;
    }

        /* 访问栈顶元素 */
        int top() {
            if (isEmpty())
                throw out_of_range("栈为空");
            return stackTop->val;
    }

        /* 将 List 转化为 Array 并返回 */
        vector<int> toVector() {
            ListNode *node = stackTop;
            vector<int> res(size());
            for (int i = res.size() - 1; i >= 0; i--) {
                res[i] = node->val;
                node = node->next;
        }
        return res;
    }
};
```

:::


# Markdown Extension Examples

This page demonstrates some of the built-in markdown extensions provided by VitePress.

## Syntax Highlighting

VitePress provides Syntax Highlighting powered by [Shikiji](https://github.com/antfu/shikiji), with additional features like line-highlighting:

**Input**

````md
```js{4}
export default {
  data () {
    return {
      msg: 'Highlighted!'
    }
  }
}
```
````

**Output**

```js{4}
export default {
  data () {
    return {
      msg: 'Highlighted!'
    }
  }
}
```

## Custom Containers

**Input**

```md
::: info
This is an info box.
:::

::: tip
This is a tip.
:::

::: warning
This is a warning.
:::

::: danger
This is a dangerous warning.
:::

::: details
This is a details block.
:::
```

**Output**

::: info
This is an info box.
:::

::: tip 💡 Tip
This is a tip.
:::

::: warning
This is a warning.
:::

::: danger
This is a dangerous warning.
:::

::: details
This is a details block.
:::

## More

Check out the documentation for the [full list of markdown extensions](https://vitepress.dev/guide/markdown).
